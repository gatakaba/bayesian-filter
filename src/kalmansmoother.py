# coding:utf-8
"""
=====================================
Inference for Dynamic Linear Systems
=====================================

# features
* estimate current state
* predict after k step state
* predict after k step observation

"""
import numpy as np


class KalmanSmoother(object):
    """カルマンスムーザの実装
        * p(z_{n+1}|z_{n}) = N(z_{n+1}|A z_{n},\gamma)
        * p(x_{n}|z_{n}) = N(x_{n}|C z_{n},\sigma)

    Parameters
    ----------
    transition_matrix : ndarray, shape = (state_dim, state_dim)

    observation_matrix : ndarray, shape = (observation_dim, state_dim)

    process_noise : ndarray, shape = (state_dim, state_dim)
        also known as process_covariance_matrix.

    observation_noise : ndarray, shape = (observation_dim, ovservation_dim)
        also known as observation_covariance_matrix.

    initial_mean : ndarray, shape = (state_dim), optional
        mean of the initial state.
        if you don't set, initial state will generated by Normal(z|0, initial_covariance)

    initial_covariance : ndarray, shape = (state_dim, state_dim), optional
        covariance of the inital state.
        if you don't set, initial covariance will be I * 10 ** 4

    drive_matrix : ndarray, shape = (state_dim, input_dim), optional

    """

    def __init__(self, transition_matrix, observation_matrix, process_noise, observation_noise, initial_mean=None,
                 initial_covariance=None, drive_matrix=None):

        self.A = transition_matrix  # 遷移行列
        self.B = drive_matrix  # 駆動行列
        self.C = observation_matrix  # 観測行列

        self.Q = process_noise  # プロセスノイズの分散共分散行列
        self.R = observation_noise  # 観測ノイズの分散共分散行列

        self.K = None  # カルマンゲイン

        self.N = self.A.shape[0]  # 状態量の次元数
        self.M = self.C.shape[0]  # 観測値の次元数

        # 推定誤差分散共分散行列
        if not initial_covariance is None:
            self.P = initial_covariance
        else:
            self.P = np.eye(self.N) * 10 ** 4

        # 状態量の条件付き期待値
        if not initial_mean is None:
            self.m = initial_mean
        else:
            self.m = np.random.multivariate_normal(np.zeros(self.N), self.P)
        self.check_parameter_size()

    @property
    def state_dim(self):
        return self.N

    @property
    def observation_dim(self):
        return self.M

    @property
    def current_state(self):
        return self.m, self.P

    @property
    def transition_matrix(self):
        return self.A

    @property
    def observation_matrix(self):
        return self.C

    @property
    def process_noise(self):
        return self.Q

    @property
    def observation_noise(self):
        return self.R

    def check_parameter_size(self):

        if not (self.N == self.A.shape[0] == self.A.shape[1] == self.C.shape[1] == self.Q.shape[0] == self.Q.shape[1]):
            raise ValueError("parameter size is not adequate check system dimension")

        if not (self.M == self.C.shape[0] == self.R.shape[0] == self.R.shape[1]):
            print(self.M, self.C.shape, self.R.shape)

            raise ValueError("parameter size is not adequate check observe dimension")

    def smoothing(self, observerd_data_list, input_data=None):
        """ smoothing.

        Parameters
        ----------
        observerd_data_list : ndarray ,shape = (n_samples, observation_dim)

        input_data : ndarray ,shape = (input_dim)

        Returns
        -------
        smoothed_data : ndarray ,shape = (n_samples, observation_dim)
        """

        # 状態量推定
        state_mean_list = []
        state_covariance_list = []

        for observed_data in observerd_data_list:
            self.update(observed_data)
            state_mean_list.append(self.m)
            state_covariance_list.append(self.P)

    def update(self, observerd_data, input_data=None):
        """ update state.

        p(z_{k}|x_{1:k})

        推定した状態量を取得したい場合、current_stateにアクセスして下さい (← bad comment)

        Parameters
        ----------
        observerd_data : ndarray ,shape = (observation_dim)

        input_data : ndarray ,shape = (input_dim)

        Returns
        -------
        self : object
            Returns the instance itself.
        """

        x = observerd_data
        u = input_data
        A, B, C, Q, R = self.A, self.B, self.C, self.Q, self.R
        m = np.copy(self.m)
        P = np.copy(self.P)

        # prediction step
        if not (u is None):
            m = A @ m + B @ u
        else:
            m = A @ m
        P = A @ P @ A.T + Q

        # update step
        S = C @ P @ C.T + R
        K = P @ C.T @ np.linalg.inv(S)
        m = m + K @ (x - C @ m)
        P = P - K @ S @ K.T

        # update parameter
        self.m = m
        self.P = P
        return self


if __name__ == "__main__":
    A = np.array([[1, 0.1],
                  [0, 1]])

    C = np.atleast_2d([1, 0])

    Q = np.array([[1, 0], [0, 1]])
    R = np.eye(1)

    ks = KalmanSmoother(A, C, Q, R)
    x = np.random.normal(0, 100, size=100)
    x = np.cumsum(x)
    ks.smoothing(x)
